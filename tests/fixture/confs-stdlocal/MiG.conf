# This is the MiG specific apache configuration.
# It overrides some settings from the main configuration to be able to simply
# include this configuration from any 'vanilla' httpd.conf.
# Only tested with debian + apache 2.2+ but should work with others.

# Server name - comment out to just use hostname
<IfDefine BASE_FQDN>
ServerName ${BASE_FQDN}
</IfDefine>

# Point users in the right direction on errors
ServerAdmin testuser

# We may need to run as MiG user or group for file access to work
# through CGI scripts and for direct user file access
User testuser
Group testgroup

# Performance Tuning
StartServers 5
# NOTE: increasing Serverlimit is required to exceed 256 workers
ServerLimit 256
# These two were renamed in apache 2.4
<IfVersion >= 2.4>
    MaxRequestWorkers 256
    MaxConnectionsPerChild 10000
</IfVersion>
<IfVersion < 2.4>
    MaxClients 256
    MaxRequestsPerChild 10000
</IfVersion>

# Do not allow TRACE requests, as recommended by OpenVAS/GVM scan results
TraceEnable off

# Default target for all directories not explicitly configured
<Directory "/">
    # Disable all overrides
    AllowOverride None
    # Enable FollowSymlinks and nothing else for all sub dirs
    Options FollowSymlinks
    # Deny all access to base mig dir and only allow on a subdir basis
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</Directory>
# Prevent .htaccess and .htpasswd files from being viewed by Web clients. 
# This may already be set in apache2.conf but better safe than sorry
<Files ~ "^\.ht">
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</Files>
# TODO: eliminate legacy /images and use /assets everywhere
# Public images shared by http and https pages and scripts
Alias /images/ "/home/mig/mig/images/"
# Bind favicon once and for all
Alias /favicon.ico "/home/mig/mig/images/skin/migrid-basic/favicon.ico"
<Directory "/home/mig/mig/images">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>
# Public images, style and script shared by http and https pages and scripts
Alias /assets/ "/home/mig/mig/assets/"
<Directory "/home/mig/mig/assets">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>
# Other public data shared by http and https pages and scripts
Alias /public/ "/home/mig/state/wwwpublic/"
# Bind security.txt (https://securitytxt.org/) once and for all
Alias /.well-known/security.txt "/home/mig/state/wwwpublic/.well-known/security.txt"
<IfDefine STATUS_ALIAS_FQDN>
# Status page helpers
Alias /status.html "/home/mig/state/wwwpublic/status.html"
Alias /status-events.json "/home/mig/state/wwwpublic/status-events.json"
</IfDefine>
<Directory "/home/mig/state/wwwpublic">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>

# Prevent access to repository dot files to avoid semi-public information leak
<DirectoryMatch "^(/home/mig/state|/home/mig/mig)/(.+/)?\.(cvs|svn|git|hg)">
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</DirectoryMatch>

# Support relocatable configuration if possible
<IfModule mod_env.c>
    # NOTE: PYTHONPATH is needed for cgi-X to work with absolute imports
    SetEnv PYTHONPATH /home/mig
    SetEnv MIG_CONF /home/mig/mig/server/MiGserver.conf
</IfModule>

<IfModule mod_headers.c>
    # Set Content-Security-Policy to prevent iframe clickjacking as
    # recommended by W3C and security scans.
    Header always set Content-Security-Policy: "frame-ancestors 'self';"

    # Set Referrer-Policy to prevent referrer info leaking to external sites as
    # recommended by W3C and security scans.
    Header always set Referrer-Policy "strict-origin-when-cross-origin"

    # Set X-Content-Type-Options to harden for XSS abusing script or styles as
    # recommended by W3C and security scans.
    Header always set X-Content-Type-Options: "nosniff"

    # Force IE browsers to exit compatibility mode even if enabled for all 
    # intranet sites, which is the standard policy in some places.
    <FilesMatch "(^$|\.(htm|html)$)">
        BrowserMatch MSIE ie
        Header set X-UA-Compatible "IE=Edge,chrome=1" env=ie
    </FilesMatch>
</IfModule>

<IfModule mod_mime.c>
    # NOTE: workaround for broken double gzip decompression e.g. in Firefox.
    #       The bam files are in fact already gzip files and require care:
    #       https://github.com/igvteam/igv.js/wiki/Data-Server-Requirements#bam-mime-type
    #       otherwise HTTP GET may result in silent unzip and file truncation.
    AddType application/octet-stream .bam
</IfModule>

# Configure WSGI if available
<IfModule mod_wsgi.c>
    # Run WSGI in daemon mode with multiprocessing-only for isolation.
    # Additional information in 'The mod_wsgi Daemon Processes' on:
    # https://modwsgi.readthedocs.io/en/develop/user-guides/processes-and-threading.html
    #
    # We preserve the default WSGIApplicationGroup setting of '%{RESOURCE}'
    # to force every single application into a dedicated sub-interpreter
    # for complete isolation. This includes different VGrid Trac instances.
    # Please note that the processes number here is a FIXED cap on available 
    # worker processes so it strictly limits the number of concurrent clients.
    <IfDefine BASE_FQDN>
        WSGIDaemonProcess ${BASE_FQDN} processes=10 threads=1 display-name=%{GROUP} user=testuser group=testgroup python-path=/home/mig/mig  maximum-requests=1000
        WSGIProcessGroup ${BASE_FQDN}
    </IfDefine>
    # Make sure wsgi sockets are fully accessible to testuser
    # NOTE: make sure SELinux or similar isn't interfering if apache still
    # gets permission errors on startup
    WSGISocketPrefix /home/mig/mig/wsgi-bin/wsgi
</IfModule>

# Configure PUT script
<IfModule mod_actions.c>
    #
    # Action lets you define media types that will execute a script
    # whenever a matching file is called. This eliminates the need for
    # repeated URL pathnames for oft-used CGI file processors.
    # Format: Action media/type /cgi-script/location
    # Format: Action handler-name /cgi-script/location
    #
    # We need to let implicit put hit SID to allow resources and oneclick
    # Browser upload uses POST and migscripts use explict CERTPUT
    Script PUT /cgi-sid/put
    Script SIDPUT /cgi-sid/put
    Script CERTPUT /cgi-bin/put
</IfModule>

# Configure internal proxy support
<IfModule mod_proxy.c>
    # For security reasons we prevent Apache from acting like a forward proxy
    ProxyRequests Off
</IfModule>

# Configure TLS/SSL
# The whole SSL configuration in this context applies both to
# the main server and all TLS/SSL-enabled virtual hosts.
<IfModule mod_ssl.c>
    # These should only be explicitly set if not already set
    # elsewhere. This is the case with custom ports or with old
    # apache 1.3.x on Debian, so listen_prefix should be set to '#'
    # with apache 2.x when ports are already configured elsewhere.
    <IfDefine PUBLIC_FQDN>
    <IfDefine PUBLIC_HTTP_PORT>
    #Listen ${PUBLIC_HTTP_PORT}
    </IfDefine>
    <IfDefine PUBLIC_HTTPS_PORT>
    #Listen ${PUBLIC_HTTPS_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine MIG_CERT_FQDN>
    <IfDefine MIG_CERT_PORT>
    #Listen ${MIG_CERT_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_CERT_FQDN>
    <IfDefine EXT_CERT_PORT>
    #Listen ${EXT_CERT_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine MIG_OID_FQDN>
    <IfDefine MIG_OID_PORT>
    #Listen ${MIG_OID_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_OID_FQDN>
    <IfDefine EXT_OID_PORT>
    #Listen ${EXT_OID_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_OIDC_FQDN>
    <IfDefine EXT_OIDC_PORT>
    #Listen ${EXT_OIDC_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine SID_FQDN>
    <IfDefine SID_PORT>
    #Listen ${SID_PORT}
    </IfDefine>
    </IfDefine>

    # Apache 2.4 changed SSL DN format - Force legacy format that we rely on
    <IfVersion >= 2.4>
        SSLOptions +LegacyDNStringFormat
    </IfVersion>

    # Some MIME-types for downloading Certificates and CRLs
    AddType application/x-x509-ca-cert .crt
    AddType application/x-pkcs7-crl .crl

    # Semaphore:
    #   Configure the path to the mutual exclusion semaphore the
    #   SSL engine uses internally for inter-process synchronization.
    # Changed from SSLMutex to just Mutex in apache>=2.4
    <IfVersion >= 2.4>
        Mutex sem
    </IfVersion>
    <IfVersion < 2.4>
        SSLMutex sem
    </IfVersion>

    # Inter-Process Session Cache:
    #   Configure the SSL Session Cache: First either `none'
    #   or `dbm:/path/to/file' for the mechanism to use and
    #   second the expiring timeout (in seconds).
    # Changed from shm to shmcb in apache 2.4
    <IfVersion >= 2.4>
        SSLSessionCache shmcb:/var/run/mod_ssl_scache
    </IfVersion>
    <IfVersion < 2.4>
        SSLSessionCache shm:/var/run/mod_ssl_scache
    </IfVersion>
    
    SSLSessionCacheTimeout 300

    # Pseudo Random Number Generator (PRNG):
    #   Configure one or more sources to seed the PRNG of the 
    #   SSL library. The seed data should be of good random quality.
    SSLRandomSeed startup file:/dev/urandom 1024
    SSLRandomSeed connect file:/dev/urandom 1024

    #   SSL Cipher Suite:
    #   List the ciphers that the client is permitted to negotiate.
    #   See the mod_ssl documentation for a complete list.
    SSLHonorCipherOrder On
    
    # IMPORTANT: these are *generated* hardened values based on generateconf
    # invocation. Any permanent changes need to be made there.
    SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
    SSLProxyCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384

    #   Server Certificate:
    #   Point SSLCertificateFile at a PEM encoded certificate.  If
    #   the certificate is encrypted, then you will be prompted for a
    #   pass phrase.  Note that a kill -HUP will prompt again. A test
    #   certificate can be generated with `make certificate' under
    #   built time. Keep in mind that if you've both a RSA and a DSA
    #   certificate you can configure both in parallel (to also allow
    #   the use of DSA ciphers, etc.)
    SSLCertificateFile /home/mig/certs/server.crt

    #   Server Private Key:
    #   If the key is not combined with the certificate, use this
    #   directive to point at the key file.  Keep in mind that if
    #   you've both a RSA and a DSA private key you can configure
    #   both in parallel (to also allow the use of DSA ciphers, etc.)
    SSLCertificateKeyFile /home/mig/certs/server.key

    #   Optional Certificate Authority (CA):
    #   Set the CA certificate verification path where to find CA
    #   certificates for client authentication or alternatively one
    #   huge file containing all of them (file must be PEM encoded)
    #   Note: Inside SSLCACertificatePath you need hash symlinks
    #         to point to the certificate files. Use the provided
    #         Makefile to update the hash symlinks after changes.
    # SSLCACertificateFile /home/mig/certs/cacert.pem

    #   Optional Certificate Revocation Lists (CRL):
    #   Set the CA revocation path where to find CA CRLs for client
    #   authentication or alternatively one huge file containing all
    #   of them (file must be PEM encoded)
    #   Note: Inside SSLCARevocationPath you need hash symlinks
    #         to point to the certificate files. Use the provided
    #         Makefile to update the hash symlinks after changes.
    # SSLCARevocationFile /home/mig/certs/crl.pem

    # Apache 2.4 defaults to not check CRL at all
    <IfVersion >= 2.4>
        # SSLCARevocationCheck chain
    </IfVersion>

    #   SSL Protocol Adjustments:
    #   The safe and default but still SSL/TLS standard compliant shutdown
    #   approach is that mod_ssl sends the close notify alert but doesn't
    #   wait for the close notify alert from client. When you need a
    #   different shutdown approach you can use one of the following
    #   variables:
    #   o ssl-unclean-shutdown:
    #     This forces an unclean shutdown when the connection is closed, 
    #     i.e. no SSL close notify alert is send or allowed to received.
    #     This violates the SSL/TLS standard but is needed for some 
    #     brain-dead browsers. Use this when you receive I/O errors because
    #     of the standard approach where mod_ssl sends the close notify
    #     alert.
    #   o ssl-accurate-shutdown:
    #     This forces an accurate shutdown when the connection is closed, 
    #     i.e. a SSL close notify alert is send and mod_ssl waits for the
    #     close notify alert of the client. This is 100% SSL/TLS standard
    #     compliant, but in practice often causes hanging connections with
    #     brain-dead browsers. Use this only for browsers where you know
    #     that their SSL implementation works correctly. 
    #   Notice: Most problems of broken clients are also related to the
    #   HTTP keep-alive facility, so you usually additionally want to
    #   disable keep-alive for those clients, too. Use variable
    #   "nokeepalive" for this.
    #   Similarly, one has to force some clients to use HTTP/1.0 to
    #   workaround their broken HTTP/1.1 implementation. Use variables
    #   "downgrade-1.0" and "force-response-1.0" for this.
    #
    # NB: The default setting of degrading ALL IE versions to 1.0 and no
    # keepalive is way too harsh. Changed to only include the unclean shutdown
    # which is still there at least in IE 6-9
    #SetEnvIf User-Agent ".*MSIE.*" \
    #    nokeepalive ssl-unclean-shutdown \
    #    downgrade-1.0 force-response-1.0
    #SetEnvIf User-Agent ".*MSIE.*" \
    SetEnvIf User-Agent ".*MSIE [6-9].*" \
        ssl-unclean-shutdown

    # Disable old weak SSL and pre TLSv1.2 implementations
    SSLProtocol All -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLProxyProtocol All -SSLv2 -SSLv3 -TLSv1 -TLSv1.1

    # Prevent the CRIME attack vector completely
    # SSLCompression option requires apache 2.2.24+
    <IfVersion >= 2.4>
        SSLCompression off
    </IfVersion>
    <IfVersion < 2.4>
        # Fall back to backwards compatible Location method if not recent
        <Location />
            SetEnv no-gzip
        </Location>
    </IfVersion>

    # Use dhparams directly if apache is recent enough.
    # For slightly older versions of apache one can instead concatenate
    # the dhparams file into the server certificate file for the same effect.
    <IfVersion >= 2.4.8>
        SSLOpenSSLConfCmd DHParameters "/home/mig/certs/dhparams.pem"
    </IfVersion>

</IfModule>

# Configure public access plain http virtual host
<IfDefine PUBLIC_FQDN>
<IfDefine PUBLIC_HTTP_PORT>
# NOTE: use either of these depending on your certificate authority setup.
# Basic setup with server certificate from external certificate authority.
<VirtualHost ${PUBLIC_FQDN}:${PUBLIC_HTTP_PORT}>
# For e.g. Letsencrypt server certificate with http verification of domains.
#<VirtualHost *:${PUBLIC_HTTP_PORT}>
    ServerName ${PUBLIC_FQDN}
    #ServerAlias         
    <IfDefine PUBLIC_ALIAS_FQDN>
    ServerAlias ${PUBLIC_ALIAS_FQDN}
    </IfDefine>
    <IfDefine STATUS_ALIAS_FQDN>
    ServerAlias ${STATUS_ALIAS_FQDN}
    </IfDefine>
    # Optionally add extra server aliases for current and future use here
    #ServerAlias something. somethingelse.

    # General setup for the virtual host
    DocumentRoot "/home/mig/state/wwwpublic"
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log common

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Let all certificate validation requests on plain http through unaltered
    #RewriteCond %{HTTPS} off
    #RewriteCond %{REQUEST_URI} ^/.well-known/acme-challenge/
    #RewriteRule ^ - [L]

    # NOTE: redirect all plain http requests on BASE, PUBLIC and ALIAS to https
    #       if available to increase security
    <IfDefine PUBLIC_HTTPS_PORT>
       RewriteCond %{HTTPS} off
       RewriteCond %{HTTP_HOST} ^${BASE_FQDN}$
       RewriteRule ^/?(.*) https://${PUBLIC_FQDN}:${PUBLIC_HTTPS_PORT}/$1 [R,L]
       
       RewriteCond %{HTTPS} off
       RewriteCond %{HTTP_HOST} ^${PUBLIC_FQDN}$
       RewriteRule ^/?(.*) https://${PUBLIC_FQDN}:${PUBLIC_HTTPS_PORT}/$1 [R,L]
       
       <IfDefine PUBLIC_ALIAS_FQDN>
           RewriteCond %{HTTPS} off
           RewriteCond %{HTTP_HOST} ^${PUBLIC_ALIAS_FQDN}$
           RewriteRule ^/?(.*) https://${PUBLIC_ALIAS_FQDN}:${PUBLIC_HTTPS_PORT}/$1 [R,L]
       </IfDefine>
       <IfDefine STATUS_ALIAS_FQDN>
           RewriteCond %{HTTPS} off
           RewriteCond %{HTTP_HOST} ^${STATUS_ALIAS_FQDN}$
           RewriteRule ^/?(.*) https://${STATUS_ALIAS_FQDN}:${PUBLIC_HTTPS_PORT}/$1 [R,L]
       </IfDefine>
    </IfDefine>

    # NOTE: redirect all remaining enabled protected address requests to https
    #       Applies in general and specifically works around Seafile avatar bug
    #       when served on SID vhost.
    <IfDefine MIG_CERT_FQDN>
    <IfDefine MIG_CERT_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${MIG_CERT_FQDN}$
        RewriteRule ^/?(.*) https://${MIG_CERT_FQDN}:${MIG_CERT_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_CERT_FQDN>
    <IfDefine EXT_CERT_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${EXT_CERT_FQDN}$
        RewriteRule ^/?(.*) https://${EXT_CERT_FQDN}:${EXT_CERT_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>
    <IfDefine MIG_OID_FQDN>
    <IfDefine MIG_OID_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${MIG_OID_FQDN}$
        RewriteRule ^/?(.*) https://${MIG_OID_FQDN}:${MIG_OID_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_OID_FQDN>
    <IfDefine EXT_OID_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${EXT_OID_FQDN}$
        RewriteRule ^/?(.*) https://${EXT_OID_FQDN}:${EXT_OID_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>
    # TODO: implement native openid connect service and enable next lines
    #<IfDefine MIG_OIDC_FQDN>
    #<IfDefine MIG_OIDC_PORT>
    #    RewriteCond %{HTTPS} off
    #    RewriteCond %{HTTP_HOST} ^${MIG_OIDC_FQDN}$
    #    RewriteRule ^/?(.*) https://${MIG_OIDC_FQDN}:${MIG_OIDC_PORT}/$1 [R,L]
    #</IfDefine>
    #</IfDefine>
    <IfDefine EXT_OIDC_FQDN>
    <IfDefine EXT_OIDC_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${EXT_OIDC_FQDN}$
        RewriteRule ^/?(.*) https://${EXT_OIDC_FQDN}:${EXT_OIDC_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>
    <IfDefine SID_FQDN>
    <IfDefine SID_PORT>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${SID_FQDN}$
        RewriteRule ^/?(.*) https://${SID_FQDN}:${SID_PORT}/$1 [R,L]
    </IfDefine>
    </IfDefine>

    ### IMPORTANT: we only get here if no public https vhost is available

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/
    RewriteRule ^ - [L]

    # Simple rewrite to map vgrid_label value into vgrid public web location
    RewriteCond %{REQUEST_URI} ^/(VGrid|VGRID)/.*$
    RewriteRule ^/(VGrid|VGRID)/(.*) /vgrid/$2 [N]

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%1 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to public file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /vgrid/$1/$2 [L,R]
    
    ### All public vgrid component access is disabled to avoid abuse

    # Redirect to public vgrid components
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # We need to let vgrid component Xgi requests pass through to
    # *ScriptAlias* handlers.
    #RewriteRule ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /vgrid/$1/$2/$3/$4 [L,PT]

    # Public vgrid component scripts
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
    </IfModule>
</VirtualHost>
</IfDefine>
</IfDefine>

# Configure TLS/SSL public virtual host(s)
<IfDefine PUBLIC_FQDN>
<IfDefine PUBLIC_HTTPS_PORT>
<VirtualHost ${PUBLIC_FQDN}:${PUBLIC_HTTPS_PORT}>
    ServerName ${PUBLIC_FQDN}
    ServerAlias 
    <IfDefine STATUS_ALIAS_FQDN>
    ServerAlias ${STATUS_ALIAS_FQDN}
    </IfDefine>
    # Optionally add extra server aliases for current and future use here
    #ServerAlias something. somethingelse.

    # General setup for the virtual host
    DocumentRoot "/home/mig/state/wwwpublic"
    ErrorLog /var/log/apache2/ssl-error.log
    CustomLog /var/log/apache2/ssl-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${PUBLIC_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${PUBLIC_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${PUBLIC_FQDN}/server.ca.pem

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    <IfDefine STATUS_ALIAS_FQDN>
    # Redirect implict target to status page
    RewriteCond %{SERVER_NAME} ^${STATUS_ALIAS_FQDN}$
    RewriteRule ^(/*)$ /status.html [L,R]
    </IfDefine>

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/
    RewriteRule ^ - [L]

    # Simple rewrite to map vgrid_label value into vgrid public web location
    RewriteCond %{REQUEST_URI} ^/(VGrid|VGRID)/.*$
    RewriteRule ^/(VGrid|VGRID)/(.*) /vgrid/$2 [N]

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%1 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to public file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /vgrid/$1/$2 [L,R]
    
    ### All public vgrid component access is disabled to avoid abuse

    # Redirect to public vgrid components
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # We need to let vgrid component Xgi requests pass through to
    # *ScriptAlias* handlers.
    #RewriteRule ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /vgrid/$1/$2/$3/$4 [L,PT]

    # Public vgrid component scripts
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
    </IfModule>
</VirtualHost>
</IfDefine>
</IfDefine>

# Configure TLS/SSL public alias virtual host(s)
<IfDefine PUBLIC_ALIAS_FQDN>
<VirtualHost ${PUBLIC_ALIAS_FQDN}:${PUBLIC_HTTPS_PORT}>
    ServerName ${PUBLIC_ALIAS_FQDN}
    <IfDefine STATUS_ALIAS_FQDN>
    ServerAlias ${STATUS_ALIAS_FQDN}
    </IfDefine>
    # General setup for the virtual host
    DocumentRoot "/home/mig/state/wwwpublic"
    ErrorLog /var/log/apache2/ssl-error.log
    CustomLog /var/log/apache2/ssl-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    SSLCertificateFile /home/mig/certs/${PUBLIC_ALIAS_FQDN}/server.crt
    SSLCertificateKeyFile /home/mig/certs/${PUBLIC_ALIAS_FQDN}/server.key
    SSLCertificateChainFile /home/mig/certs/${PUBLIC_ALIAS_FQDN}/server.ca.pem

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    <IfDefine STATUS_ALIAS_FQDN>
    # Redirect implict target to status page
    RewriteCond %{SERVER_NAME} ^${STATUS_ALIAS_FQDN}$
    RewriteRule ^(/*)$ /status.html [L,R]
    </IfDefine>

    # Break rewriting chain for commonly-requested final destinations
    # * Internal Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/
    RewriteRule ^ - [L]

    # Simple rewrite to map vgrid_label value into vgrid public web location
    RewriteCond %{REQUEST_URI} ^/(VGrid|VGRID)/.*$
    RewriteRule ^/(VGrid|VGRID)/(.*) /vgrid/$2 [N]

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%1 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to public file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /vgrid/$1/$2 [L,R]
    
</VirtualHost>
</IfDefine>

# Configure TLS/SSL with certificates virtual host(s)
<IfDefine MIG_CERT_FQDN>
<IfDefine MIG_CERT_PORT>
# SSL with certificate from local CA
<VirtualHost ${MIG_CERT_FQDN}:${MIG_CERT_PORT}>
    # General setup for the virtual host
    ServerName ${MIG_CERT_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    #ServerAlias ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "/home/mig/state/user_home"
    ErrorLog /var/log/apache2/ssl-cert-error.log
    CustomLog /var/log/apache2/ssl-cert-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${MIG_CERT_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${MIG_CERT_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${MIG_CERT_FQDN}/server.ca.pem

    # Keep cgi-cert name for backwards compatibility but point it
    # to cgi-bin
    ScriptAlias /cgi-cert/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-bin/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient require
    SSLVerifyDepth 10

    # Pass cert DN as REMOTE_USER env for symmetry with openid login
    SSLUserName SSL_CLIENT_S_DN

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-cert-rewrite.log
        RewriteLogLevel 0
    </IfVersion>
    
    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want the PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=DIKU/OU=NA/CN=Jonas Bardino/emailAddress=bardino@diku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=DIKU+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@diku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:/home/mig/mig/server/chkuserroot.py testuser:testgroup

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Prepend certificate DN so that we can modify it further without PATH
    # interference.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:ENV:SSL_CLIENT_S_DN} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /cert_mangle/%{LA-U:ENV:SSL_CLIENT_S_DN}/cert_mangle/$1 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^/cert_mangle/(.*)\ (.*)/cert_mangle/(.*)$ /cert_mangle/$1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^/cert_mangle/(.*)/(.*)/cert_mangle/(.*)$ /cert_mangle/$1+$2/cert_mangle/$3 [N]

    # Keep replacing double backslash from utf8 chars in DN with actual char
    # E.g. to replace the 'oslash' letter on the form \\xC3\\xB8 with %C3%B8

    RewriteRule ^/cert_mangle/(.*)\\x(..)(.*)/cert_mangle/(.*)$ /cert_mangle/$1${unescape:%$2}$3/cert_mangle/$4 [N]

    # Finally remove certificate marker and unescape previously escaped path
    RewriteRule ^/cert_mangle/(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [N]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    <Directory "/home/mig/mig/cgi-bin">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/mig/software-repository">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/mig/cgi-sid">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home">
        # User home base is used for a number of public images and
        # templates.
        # Require a valid signed certificate for access to home base
        # and to individual user sub directories.
        # Access to user home dirs is further limited in .htaccess
        # files there.
        # The next line is crucial for cert_redirect to work!!!
        SSLOptions +StdEnvVars +ExportCertData
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/*/">
        # Enable cert based auth with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "/home/mig/state/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    <LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
        SSLUserName SSL_CLIENT_S_DN_Email
    </LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]

    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia

    #
    # JupyterHub server
    #
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    #ProxyPass /paraview http://localhost:8080/paraview

    # This is the path of the mapping file
    #RewriteMap session-to-port txt:/home/mig/state/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    #RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    #RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

</VirtualHost>
</IfDefine>
</IfDefine>

<IfDefine EXT_CERT_FQDN>
<IfDefine EXT_CERT_PORT>
# SSL with certificate from external CA that we trust
<VirtualHost ${EXT_CERT_FQDN}:${EXT_CERT_PORT}>
    # General setup for the virtual host
    ServerName ${EXT_CERT_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    #ServerAlias ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "/home/mig/state/user_home"
    ErrorLog /var/log/apache2/ssl-cert-error.log
    CustomLog /var/log/apache2/ssl-cert-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${EXT_CERT_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${EXT_CERT_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${EXT_CERT_FQDN}/server.ca.pem

    # Keep cgi-cert name for backwards compatibility but point it
    # to cgi-bin
    ScriptAlias /cgi-cert/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-bin/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient require
    SSLVerifyDepth 10

    # Pass cert DN as REMOTE_USER env for symmetry with openid login
    SSLUserName SSL_CLIENT_S_DN

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-cert-rewrite.log
        RewriteLogLevel 0
    </IfVersion>
    
    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want the PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=DIKU/OU=NA/CN=Jonas Bardino/emailAddress=bardino@diku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=DIKU+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@diku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:/home/mig/mig/server/chkuserroot.py testuser:testgroup

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Prepend certificate DN so that we can modify it further without PATH
    # interference.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:ENV:SSL_CLIENT_S_DN} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /cert_mangle/%{LA-U:ENV:SSL_CLIENT_S_DN}/cert_mangle/$1 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^/cert_mangle/(.*)\ (.*)/cert_mangle/(.*)$ /cert_mangle/$1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^/cert_mangle/(.*)/(.*)/cert_mangle/(.*)$ /cert_mangle/$1+$2/cert_mangle/$3 [N]

    # Keep replacing double backslash from utf8 chars in DN with actual char
    # E.g. to replace the 'oslash' letter on the form \\xC3\\xB8 with %C3%B8

    RewriteRule ^/cert_mangle/(.*)\\x(..)(.*)/cert_mangle/(.*)$ /cert_mangle/$1${unescape:%$2}$3/cert_mangle/$4 [N]

    # Finally remove certificate marker and unescape previously escaped path
    RewriteRule ^/cert_mangle/(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [N]
    
    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    <Directory "/home/mig/mig/cgi-bin">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/mig/software-repository">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/mig/cgi-sid">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home">
        # User home base is used for a number of public images and
        # templates.
        # Require a valid signed certificate for access to home base
        # and to individual user sub directories.
        # Access to user home dirs is further limited in .htaccess
        # files there.
        # The next line is crucial for cert_redirect to work!!!
        SSLOptions +StdEnvVars +ExportCertData
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/*/">
        # Enable cert based auth with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "/home/mig/state/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    <LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
        SSLUserName SSL_CLIENT_S_DN_Email
    </LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia

    #
    # JupyterHub server
    #
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    #ProxyPass /paraview http://localhost:8080/paraview

    # This is the path of the mapping file
    #RewriteMap session-to-port txt:/home/mig/state/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    #RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    #RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

</VirtualHost>
</IfDefine>
</IfDefine>


<IfModule mod_auth_openid.cpp>
# Configure TLS/SSL with openid virtual host(s) if enabled
<IfDefine MIG_OID_FQDN>
<IfDefine MIG_OID_PORT>
# SSL with OpenID access based on user login against local MiG user DB
<VirtualHost ${MIG_OID_FQDN}:${MIG_OID_PORT}>
    # General setup for the virtual host
    ServerName ${MIG_OID_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    #ServerAlias ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "/home/mig/state/user_home"
    ErrorLog /var/log/apache2/ssl-oid-error.log
    CustomLog /var/log/apache2/ssl-oid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${MIG_OID_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${MIG_OID_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${MIG_OID_FQDN}/server.ca.pem

    # OpenID-based access to cgi-bin (see below)
    ScriptAlias /cgi-oid/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-bin/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    # 2FA helper
    ScriptAlias /cgi-auth/ "/home/mig/mig/cgi-auth/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # OpenID 2.0's relying party verification mechanism needs this header
        # Use cgi-sid script if available, and fall back to a static file
        <IfDefine SID_FQDN>
            Header always set X-XRDS-Location "https://${SID_FQDN}:${SID_PORT}/cgi-sid/oiddiscover.py"
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                # NOTE: the contents of this static file can be generated with:
                # cd /home/mig && python mig/server/genoiddiscovery.py > \
                #     /home/mig/state/wwwpublic/oiddiscover.xml
                # when openid is enabled in MiGserver.conf
                Header always set X-XRDS-Location "https://${BASE_FQDN}/public/oiddiscover.xml"
            </IfDefine>
        </IfDefine>
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Transfer raw OpenID username to new MIG_OID_USERNAME env for use in
    # rewrites and htaccess
    SetEnvIf %{LU-A:REMOTE_USER} ^.*/([^/]+)$ MIG_OID_USERNAME="$1"

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    ### Any special directories without openid requirement should go here...

    # Currently no such dirs except the globally configured ones at the top


    #### All other locations share basic OpenID conf and can use SSL envs

    <LocationMatch .* >
        # Where to store OpenID user session DB - must be read/write
        # to web server user (testuser)
        # Use custom location since some distros do not allow r/w in
        # apache run dir causing mod auth openid to segfault :-(
        AuthOpenIDDBLocation /home/mig/state/openid_store/mod_auth_openid-mig-users.db
        AuthOpenIDSecureCookie On
        # Default session lifetime without re-login
        AuthOpenIDCookieLifespan 43200
        # We use oidresponse page for user friendly OpenID error handling.
        # Fall back to static entry page if SID is disabled.
        <IfDefine SID_FQDN>
            AuthOpenIDLoginPage https://${SID_FQDN}:${SID_PORT}/cgi-sid/oidresponse.py
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                AuthOpenIDLoginPage https://${BASE_FQDN}/public/
            </IfDefine>
        </IfDefine>
        # Require auth by our own OpenID server and use the base URL
        # in order to have manual user ID selection
        AuthOpenIDSingleIdP 
        # Single-sign-on by forcing trust root and cookie path to server base
        AuthOpenIDTrustRoot https://${MIG_OID_FQDN}/
        AuthOpenIDCookiePath /
    </LocationMatch>

    <Directory "/home/mig/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    # Jupyter OpenID 2.0 auth
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-openid.conf

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    <Directory "/home/mig/mig/cgi-bin">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/">
        # Require a valid OpenID login for access to user home and all user
        # sub directories.
        AuthType OpenID
        require valid-user
        # Access to user home dirs is also further limited in .htaccess
        # files there.
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/*/">
        # Add additional auth restrictions with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "/home/mig/state/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>
    <LocationMatch "^/(index.html)?$">
        # Grant full access to landing page in user_home so that openid relying
        # party verification can work from index.html without an openid loop. 
        # The access restriction is there on individual user sub directories.
        # In apache-2.2 we must use Satisfy any and in 2.4 Require all granted
        # rather than Authtype None here.
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Satisfy Any
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Satisfy Any
        </IfVersion>
    </LocationMatch>
    # We allow access to cgi-sid with auth here just like for the cert case
    <Directory "/home/mig/mig/cgi-sid">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # TODO: update to use OpenID email as username here?
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    #<LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
    #    SSLUserName SSL_CLIENT_S_DN_Email
    #</LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-oid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Filter OpenID SReg noise from query string
    RewriteCond %{QUERY_STRING} ^openid.ns.sreg=http%3A%2F%2Fopenid.net%2Fextensions%2Fsreg%2F1.1$
    RewriteRule ^(.*) $1? [L,R]

    # Common destinations without explicit auth or rewrite requirements 
    # NOTE: OpenID server might need to check cgi-sid/* and root address
    # NOTE: autocreate must be kept out of 2FA to work
    RewriteCond %{REQUEST_URI} ^/(favicon.ico|)$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/(autocreate|autologout|logout).py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known|openid|cgi-sid)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # 2FA helpers based on our own 2FA helper in /home/mig/mig/cgi-auth/twofactor.py
    #
    # We add the QSA flag to have apache automatically append the query.
    RewriteCond %{REQUEST_URI} !^/wsgi-bin/twofactor.py
    RewriteCond %{HTTP_COOKIE} !^.*2FA_Auth=[a-zA-Z0-9]+ [OR]
    RewriteCond %{HTTP_COOKIE} ^.*2FA_Auth=([a-zA-Z0-9]+) 
    #RewriteCond /home/mig/state/twofactor_home/%{REMOTE_ADDR}_%1 !-l [OR]
    RewriteCond /home/mig/state/twofactor_home/%1 !-f
    RewriteRule ^(.*)$ /wsgi-bin/twofactor.py?redirect_url=$1 [QSA,L,R=302]

    # Now any 2FA is done so we proceed to scripting targets
    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-cert)/
    RewriteRule ^ - [L]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]


    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want /cert_redirect/PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=NBI/OU=NA/CN=Jonas Bardino/emailAddress=bardino@nbi.ku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=NBI+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@nbi.ku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:/home/mig/mig/server/chkuserroot.py testuser:testgroup

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Fake certificate DN so that we can modify it further without PATH
    # interference. It may already be on final format but that doesn't hurt.
    # REMOTE_USER is only available in later stages so we must use 
    # LA-U:REMOTE_USER and it contains the full OpenID URL so we strip the
    # leading prefix until after the https://a.b.c/openid/id/ part.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /strip_provider/%{LA-U:REMOTE_USER}/cert_mangle/$1 [NE,C]
    RewriteRule ^/strip_provider//*(.+)/cert_mangle/(.*) /cert_mangle/$1/cert_mangle/$2 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^/cert_mangle/(.*)\ (.*)/cert_mangle/(.*)$ /cert_mangle/$1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^/cert_mangle/(.*)/(.*)/cert_mangle/(.*)$ /cert_mangle/$1+$2/cert_mangle/$3 [N]

    # Finally remove certificate marker and unescape previously escaped path
    # IMPORTANT: all major browsers have trouble to some extent when accessing
    # the resulting cert_redirect data if we let the rules proceed as in the
    # cert case ([N]). This leads to subtle errors like IE and Chrome returning
    # an error instead of downloading e.g. PDF files when double clicking in
    # Files and FF not actually applying Settings -> style. Strangely enough
    # FF succeeds in the former and Chrome+IE in the latter case.
    # We explicitly SSL proxy ([P]) to work around the issues.

    # NOTE: we proxy here to make sure we only target cert mangled paths.
    # It does NOT mean that we skip chroot check below as that will still
    # happen in the new request caused by the proxy'ing.
    RewriteRule ^/cert_mangle/(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [P]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    # Proxy forward /openid/ to grid_openid daemon running on ${OPENID_ADDRESS}
    # IMPORTANT: edit ProxyPass port if you edit openid port in MiGserver.conf
    <IfDefine OPENID_ADDRESS>
    #<Location /openid/>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</Location>
    #ProxyPass /openid/ https://${OPENID_ADDRESS}:8443/openid/
    #ProxyPassReverse /openid/ https://${OPENID_ADDRESS}:8443/openid/
    </IfDefine>

    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia

    #
    # JupyterHub server
    #
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    #ProxyPass /paraview http://localhost:8081/paraview

    # This is the path of the mapping file
    #RewriteMap session-to-port txt:/home/mig/state/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    #RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    #RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

    <Directory /home/mig/mig/cgi-auth>
        AuthType OpenID
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
        Require valid-user
    </Directory>

</VirtualHost>
</IfDefine>
</IfDefine>

<IfDefine EXT_OID_FQDN>
<IfDefine EXT_OID_PORT>
# SSL with OpenID access based on user login against external user DB
<VirtualHost ${EXT_OID_FQDN}:${EXT_OID_PORT}>
    # General setup for the virtual host
    ServerName ${EXT_OID_FQDN}
    #<IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    ##ServerAlias ${BASE_FQDN}
    #</IfDefine>
    DocumentRoot "/home/mig/state/user_home"
    ErrorLog /var/log/apache2/ssl-oid-error.log
    CustomLog /var/log/apache2/ssl-oid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${EXT_OID_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${EXT_OID_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${EXT_OID_FQDN}/server.ca.pem

    # OpenID-based access to cgi-bin (see below)
    ScriptAlias /cgi-oid/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-bin/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    # 2FA helper
    ScriptAlias /cgi-auth/ "/home/mig/mig/cgi-auth/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # OpenID 2.0's relying party verification mechanism needs this header
        # Use cgi-sid script if available, and fall back to a static file
        <IfDefine SID_FQDN>
            Header always set X-XRDS-Location "https://${SID_FQDN}:${SID_PORT}/cgi-sid/oiddiscover.py"
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                # NOTE: the contents of this static file can be generated with:
                # cd /home/mig && python mig/server/genoiddiscovery.py > \
                #     /home/mig/state/wwwpublic/oiddiscover.xml
                # when openid is enabled in MiGserver.conf
                Header always set X-XRDS-Location "https://${BASE_FQDN}/public/oiddiscover.xml"
            </IfDefine>
        </IfDefine>
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Transfer raw OpenID username to new EXT_OID_USERNAME env for use in
    # rewrites and htaccess
    SetEnvIf %{LU-A:REMOTE_USER} ^.*/([^/]+)$ EXT_OID_USERNAME="$1"

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    ### Any special directories without openid requirement should go here...

    # Currently no such dirs except the globally configured ones at the top


    #### All other locations share basic OpenID conf and can use SSL envs

    <LocationMatch .* >
        # Where to store OpenID user session DB - must be read/write
        # to web server user (testuser)
        # Use custom location since some distros do not allow r/w in
        # apache run dir causing mod auth openid to segfault :-(
        AuthOpenIDDBLocation /home/mig/state/openid_store/mod_auth_openid-ext-users.db
        AuthOpenIDSecureCookie On
        # Default session lifetime without re-login
        AuthOpenIDCookieLifespan 43200
        # We use oidresponse page for user friendly OpenID error handling.
        # Fall back to static entry page if SID is disabled.
        <IfDefine SID_FQDN>
            AuthOpenIDLoginPage https://${SID_FQDN}:${SID_PORT}/cgi-sid/oidresponse.py
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                AuthOpenIDLoginPage https://${BASE_FQDN}/public/
            </IfDefine>
        </IfDefine>
        # Require auth by our own OpenID server and use the base URL
        # in order to have manual user ID selection
        AuthOpenIDSingleIdP 
        # Single-sign-on by forcing trust root and cookie path to server base
        AuthOpenIDTrustRoot https://${EXT_OID_FQDN}/
        AuthOpenIDCookiePath /
    </LocationMatch>

    <Directory "/home/mig/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    # Jupyter OpenID 2.0 auth
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-openid.conf

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    <Directory "/home/mig/mig/cgi-bin">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/">
        # Require a valid OpenID login for access to user home and all user
        # sub directories.
        AuthType OpenID
        require valid-user
        # Access to user home dirs is also further limited in .htaccess
        # files there.
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/*/">
        # Add additional auth restrictions with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "/home/mig/state/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>
    <LocationMatch "^/(index.html)?$">
        # Grant full access to landing page in user_home so that openid relying
        # party verification can work from index.html without an openid loop. 
        # The access restriction is there on individual user sub directories.
        # In apache-2.2 we must use Satisfy any and in 2.4 Require all granted
        # rather than Authtype None here.
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Satisfy Any
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Satisfy Any
        </IfVersion>
    </LocationMatch>
    # We allow access to cgi-sid with auth here just like for the cert case
    <Directory "/home/mig/mig/cgi-sid">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # TODO: update to use OpenID email as username here?
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    #<LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
    #    SSLUserName SSL_CLIENT_S_DN_Email
    #</LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-oid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Filter OpenID SReg noise from query string
    RewriteCond %{QUERY_STRING} ^openid.ns.sreg=http%3A%2F%2Fopenid.net%2Fextensions%2Fsreg%2F1.1$
    RewriteRule ^(.*) $1? [L,R]

    # Common destinations without explicit auth or rewrite requirements
    # NOTE: OpenID server might need to check cgi-sid/* and root address
    # NOTE: autocreate must be kept out of 2FA to work
    RewriteCond %{REQUEST_URI} ^/(favicon.ico|)$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/(autocreate|autologout|logout).py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known|openid|cgi-sid)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # 2FA helpers based on our own 2FA helper in /home/mig/mig/cgi-auth/twofactor.py
    #
    # We add the QSA flag to have apache automatically append the query.
    RewriteCond %{REQUEST_URI} !^/wsgi-bin/twofactor.py
    RewriteCond %{HTTP_COOKIE} !^.*2FA_Auth=[a-zA-Z0-9]+ [OR]
    RewriteCond %{HTTP_COOKIE} ^.*2FA_Auth=([a-zA-Z0-9]+) 
    #RewriteCond /home/mig/state/twofactor_home/%{REMOTE_ADDR}_%1 !-l [OR]
    RewriteCond /home/mig/state/twofactor_home/%1 !-f
    RewriteRule ^(.*)$ /wsgi-bin/twofactor.py?redirect_url=$1 [QSA,L,R=302]

    # Now any 2FA is done so we proceed to scripting targets
    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-cert)/
    RewriteRule ^ - [L]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]


    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want /cert_redirect/PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=NBI/OU=NA/CN=Jonas Bardino/emailAddress=bardino@nbi.ku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=NBI+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@nbi.ku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:/home/mig/mig/server/chkuserroot.py testuser:testgroup

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Fake certificate DN so that we can modify it further without PATH
    # interference. It may already be on final format but that doesn't hurt.
    # REMOTE_USER is only available in later stages so we must use 
    # LA-U:REMOTE_USER and it contains the full OpenID URL so we strip the
    # leading prefix until after the https://a.b.c/openid/id/ part.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /strip_provider/%{LA-U:REMOTE_USER}/cert_mangle/$1 [NE,C]
    RewriteRule ^/strip_provider//*(.+)/cert_mangle/(.*) /cert_mangle/$1/cert_mangle/$2 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^/cert_mangle/(.*)\ (.*)/cert_mangle/(.*)$ /cert_mangle/$1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^/cert_mangle/(.*)/(.*)/cert_mangle/(.*)$ /cert_mangle/$1+$2/cert_mangle/$3 [N]

    # Finally remove certificate marker and unescape previously escaped path
    # IMPORTANT: all major browsers have trouble to some extent when accessing
    # the resulting cert_redirect data if we let the rules proceed as in the
    # cert case ([N]). This leads to subtle errors like IE and Chrome returning
    # an error instead of downloading e.g. PDF files when double clicking in
    # Files and FF not actually applying Settings -> style. Strangely enough
    # FF succeeds in the former and Chrome+IE in the latter case.
    # We explicitly SSL proxy ([P]) to work around the issues.

    # NOTE: we proxy here to make sure we only target cert mangled paths.
    # It does NOT mean that we skip chroot check below as that will still
    # happen in the new request caused by the proxy'ing.
    RewriteRule ^/cert_mangle/(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [P]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]

    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>

    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia

    #
    # JupyterHub server
    #
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    #ProxyPass /paraview http://localhost:8081/paraview

    # This is the path of the mapping file
    #RewriteMap session-to-port txt:/home/mig/state/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    #RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    #RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

    <Directory /home/mig/mig/cgi-auth>
        AuthType OpenID
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
        Require valid-user
    </Directory>

</VirtualHost>
</IfDefine>
</IfDefine>
</IfModule>


<IfModule mod_auth_openidc.c>
<IfDefine EXT_OIDC_FQDN>
<IfDefine EXT_OIDC_PORT>
# SSL with OpenID Connect access based on user login against external user DB
<VirtualHost ${EXT_OIDC_FQDN}:${EXT_OIDC_PORT}>
    # General setup for the virtual host
    ServerName ${EXT_OIDC_FQDN}
    #<IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    ##ServerAlias ${BASE_FQDN}
    #</IfDefine>
    DocumentRoot "/home/mig/state/user_home"
    ErrorLog /var/log/apache2/ssl-oid-error.log
    CustomLog /var/log/apache2/ssl-oid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${EXT_OIDC_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${EXT_OIDC_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${EXT_OIDC_FQDN}/server.ca.pem

    # OpenID-based access to cgi-bin (see below)
    ScriptAlias /cgi-oid/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-bin/ "/home/mig/mig/cgi-bin/"
    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    # 2FA helper
    ScriptAlias /cgi-auth/ "/home/mig/mig/cgi-auth/"

    ### OpenID Connect settings
    # To avoid that size of a request header field exceeds server limit.
    LimitRequestFieldSize 65536

    # The redirect_uri for this OpenID Connect client; this is a vanity URL
    # that must ONLY point to a path on your server protected by this module
    # but it must NOT point to any actual content that needs to be served. 
    # NOTE: authenticated requests land temporarily on this URL with ID query.
    #       The precise intermediate format is: 
    #       /dynamic/redirect_uri#id_token=JWT_TOKEN&scope=SCOPENAME&state=JWT_STATE
    #       the returned id_token is JWT format as described on
    #       https://medium.com/@darutk/understanding-id-token-5f83f50fa02e
    #       but it should not be necessary to manually parse it
    #
    # The oidc auth module parses the auth ID values and sets the REMOTE_USER
    # variable to the id_token [sub] claim concatenated with the OP's Issuer
    # identifier ([sub]@[iss]). It additionally extracts and sets a number of
    # OIDC_CLAIM_{field} environment vars for easier further use. 
    # IMPORTANT: keep this address in sync with rewrite rule below to avoid
    #            permission denied during login redirect
    OIDCRedirectURI https://${EXT_OIDC_FQDN}/dynamic/redirect_uri

    # Set a password for crypto purposes, this is used for:
    # - encryption of the (temporary) state cookie
    # - encryption of cache entries, that may include the session cookie, see:
    #   OIDCCacheEncrypt and OIDCSessionType
    # NOTE: required and local to apache for protecting cookies, cache and sessions
    # IMPORTANT: it's on purpose that this secret is not exposed in conf generator!
    #            One should NEVER pass the secret on the command line.
    OIDCCryptoPassphrase "INSERT OIDC CRYPTO PASSPHRASE"

    # TODO: enable in state dir like for OpenID 2.0?
    # When using multiple OpenID Connect Providers, possibly combined with Dynamic Client
    # Registration and account-based OP Discovery.
    # Specifies the directory that holds metadata files (must be writable for the Apache process/user).
    # When not specified, it is assumed that we use a single statically configured provider as
    # described under the section "OpenID Connect Provider" below, most likely using OIDCProviderMetadataURL.
    #OIDCMetadataDir /var/cache/apache2/mod_auth_openidc/metadata

    ### IMPORTANT: the remaining values must fit your OpenID Connect identity
    ###            provider. The client ones must be negotiated specifically.

    ########################################################################################
    #
    # OpenID Connect Provider
    #
    # For configuration of a single static provider, not using OpenID Connect Provider Discovery.
    #
    ########################################################################################

    # URL where OpenID Connect Provider metadata can be found (e.g. 
    # https://accounts.google.com/.well-known/openid-configuration)
    # The obtained metadata will be cached and refreshed every 24 hours.
    #OIDCProviderMetadataURL ""

    # OpenID Connect Provider issuer identifier (e.g. https://localhost:9031 or https://accounts.google.com)
    # Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.
    #OIDCProviderIssuer ""

    # OpenID Connect Provider Authorization Endpoint URL (e.g. https://localhost:9031/as/authorization.oauth2)
    # Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.
    #OIDCProviderAuthorizationEndpoint ""

    # The fully qualified names of the files that contain the X.509 certificates with the RSA/EC public
    # keys that can be used for ID Token verification.
    # NB: this is one or more key tuples where a key tuple consists of:
    #  ["sig:"|"enc:"][<key-identifier>#]<path-to-cert>
    # and the key identifier part is required when the ID Token contains a "kid" in its header.
    # Specify the prefix "sig:" or "enc:" to indicate a key is specifically to be used for signing or encryption.
    # When not defined, ID Token validation key material has to be obtained through OIDCProviderJwksUri or OIDCProviderMetadataURL
    #OIDCProviderVerifyCertFiles ""

    # OpenID Connect Provider Token Endpoint URL (e.g. https://localhost:9031/as/token.oauth2)
    # Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.
    #OIDCProviderTokenEndpoint ""

    # Authentication method for the OpenID Connect Provider Token Endpoint.
    # When "private_key_jwt" is used, OIDCPrivateKeyFiles and OIDCPublicKeyFiles must have been set.
    # When not defined the default method from the specification is used, i.e. "client_secret_basic".
    # Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.
    # NB: this can be overridden for dynamic client registration on a per-OP basis in the .conf file using the key: token_endpoint_auth
    #OIDCProviderTokenEndpointAuth ""

    # OpenID Connect Provider UserInfo Endpoint URL (e.g. https://localhost:9031/idp/userinfo.openid)
    # When not defined no claims will be resolved from such endpoint.
    # Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.
    #OIDCProviderUserInfoEndpoint ""

    # Define the OpenID Connect scope that is requested from the OP (e.g.
    # "openid email profile").
    # When not defined, the bare minimal scope "openid" is used.
    # OIDCScope is used to specify ID claims/attributes in the returned token.
    # Available claims are listed in the json returned on server metadata URL
    # and some identity providers provide alias names for sets of them.
    # NOTE: the scope name or list must be prefixed with openid here.
    OIDCScope "openid profile email"

    # Defines the way in which the access token will be presented to the userinfo endpoint
    # "authz_header" means that the token will be presented in an "Authorization: Bearer" header using HTTP GET
    # "post_param" means that the token will be presented a form-encoded POST parameter using HTTP POST
    # When not defined the default is "authz_header".
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_token_method
    #OIDCUserInfoTokenMethod ""

    # The fully qualified names of the files that contain the PEM-formatted RSA/EC Public key or a X.509 certificates
    # that contain the RSA/EC public keys to be used for JWT (OP state/id_token) encryption by the OP.
    # One of these keys must correspond to the private keys defined in OIDCPrivateKeyFiles.
    # When not defined no encryption will be requested.
    # You can also prefix <filename> with a JWK key identifier to manually override the automatically
    # generated "kid" that will be used for this key in the JWKs derived from this certificate and
    # published at OIDCClientJwksUri.
    # Specify the prefix "sig:" or "enc:" to indicate a key is specifically to be used for signing or encryption.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key "keys" whose value is a JWK set/array (use=sign)
    #OIDCPublicKeyFiles ""

    # The fully qualified names of the files that contain the PEM-formatted RSA/EC private
    # keys that can be used to decrypt content sent to us by the OP.
    # These keys must correspond to the public keys defined in OIDCPublicKeyFiles.
    # When not defined no decryption will be possible.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key "keys" whose value is a JWK set/array (use=enc)
    #OIDCPrivateKeyFiles ""


    ########################################################################################
    #
    # OpenID Connect Client
    #
    # Settings used by the client in communication with the OpenID Connect Provider(s),
    # i.e. in Authorization Requests, Dynamic Client Registration and UserInfo Endpoint access.
    # These settings are used when a single static provider is configured and serve as defaults
    # when multiple providers are configured.
    #
    ########################################################################################

    # The response type (or OpenID Connect Flow) used (this serves as default value for discovered OPs too)
    # When not defined the "code" response type is used.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: response_type
    #OIDCResponseType ["code"|"id_token"|"id_token token"|"code id_token"|"code token"|"code id_token token"]
    # NOTE: Request user ID in all authenticated sessions
    OIDCResponseType "id_token"

    # The response mode used (this serves as default value for discovered OPs too)
    # When not defined the default response mode for the requested flow (OIDCResponseType) is used.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: response_mode
    # TODO: perhaps useful for POSTING in autocreate?
    #OIDCResponseMode [fragment|query|form_post]
    #OIDCResponseMode ""

    # Only used for a single static provider has been configured, see below in OpenID Connect Provider.
    # Client identifier used in calls to the statically configured OpenID Connect Provider.
    # NOTE: Client setup negotiated with the identity provider for this site
    #OIDCClientID ""

    # Only used for a single static provider has been configured, see below in OpenID Connect Provider.
    # Client secret used in calls to the statically configured OpenID Connect Provider.
    # (not used/required in the Implicit Client Profile, i.e. when OIDCResponseType is "id_token")
    # If the value begins with exec: the resulting command will be executed and the
    # first line returned to standard output by the program will be used as the
    # secret. The command may be absolute or relative to the web server root.
    # IMPORTANT: it's on purpose that this secret is not exposed in conf generator!
    #            One should NEVER pass the secret on the command line.
    #OIDCClientSecret "INSERT OIDC CLIENT SECRET"

    # The client name that the client registers in dynamic registration with the OP.
    # When not defined, no client name will be sent with the registration request.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: client_name
    #OIDCClientName ""

    # The contacts that the client registers in dynamic registration with the OP.
    # Must be formatted as e-mail addresses by specification.
    # Single value only; when not defined, no contact e-mail address will be sent with the registration request.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: client_contact
    #OIDCClientContact testuser@

    # The PKCE method used (this serves as default value for discovered OPs too)
    # When not defined PKCE is not used.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: pkce_method
    #OIDCPKCEMethod ""

    # The algorithm that the OP should use to encrypt the Content Encryption Key that is used to encrypt the id_token.
    # When not defined the default (by spec) is that the OP does not encrypt the id_token.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_alg
    #OIDCIDTokenEncryptedResponseAlg ""

    # The algorithm that the OP should use to encrypt to the id_token with the Content Encryption Key.
    # If OIDCIDTokenEncryptedResponseAlg is specified, the default for this value is A128CBC-HS256.
    # When OIDCIDTokenEncryptedResponseEnc is included, OIDCIDTokenEncryptedResponseAlg MUST also be provided.
    # (A256GCM algorithm only supported when using OpenSSL >= 1.0.1)
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_enc
    #OIDCIDTokenEncryptedResponseEnc ""

    # The algorithm that the OP should use to sign the UserInfo response
    # When not defined the default (by spec) is that the OP does not sign the response.
    # (ES??? algorithms only supported when using OpenSSL >= 1.0)
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_signed_response_alg
    # TODO: is this generally important in terms of trusting IDs?
    #OIDCUserInfoSignedResponseAlg ""


    ########################################################################################
    #
    # Cookie Settings
    #
    ########################################################################################

    # Define the cookie path for the "state" and "session" cookies.
    # When not defined the default is a server-wide "/".
    #OIDCCookiePath <cookie-path>

    # Define the cookie name for the session cookie.
    # When not defined the default is "mod_auth_openidc_session".
    # TODO: adjust to fit site cookie policy?
    #OIDCCookie <cookie-name>

    # Defines whether the HttpOnly flag will be set on cookies.
    # When not defined the default is On.
    #OIDCCookieHTTPOnly [On|Off]

    # Defines whether the SameSite flag will be set on cookies.
    # When On the following will apply:
    #   state cookie: Lax
    #   session cookie: Lax
    #   x_csrf discovery: Strict:
    #
    # The default `SameSite=None` cookie appendix on `Set-Cookie` response headers can be 
    # conditionally overridden using an environment variable in the Apache config as in:
    #   SetEnvIf User-Agent ".*IOS.*" OIDC_SET_COOKIE_APPEND=;
    #
    # When not defined the default is On.
    #OIDCCookieSameSite [On|Off]
    # NOTE: the default was changed from Off to On in release 2.4.15
    #OIDCCookieSameSite ""

    # Specify the names of cookies to pickup from the browser and send along on backchannel
    # calls to the OP and AS endpoints. This can be used for load-balancing purposes.
    # When not defined, no such cookies are sent.
    #OIDCPassCookies ""


    ########################################################################################
    #
    # Session Settings (only relevant in an OpenID Connect Relying Party setup)
    #
    ########################################################################################

    # Interval in seconds after which the session will be invalidated when no interaction has occurred.
    # When not defined, the default is 300 seconds.
    # NOTE: raised to a quarter
    OIDCSessionInactivityTimeout 900

    # Maximum duration of the application session
    # When not defined the default is 8 hours (3600 * 8 seconds).
    # When set to 0, the session duration will be set equal to the expiry time of the ID token.
    # NB: this can be overridden on a per-OP basis in the .conf file using the key: session_max_duration
    OIDCSessionMaxDuration 43200


    ########################################################################################
    #
    # Cache Settings
    #
    ########################################################################################

    # TODO: what cache settings do we need?

    # Cache type, used for temporary storage that is shared across Apache processes/servers for:
    #  a) session state
    #  b) nonce values to prevent replay attacks
    #  c) validated OAuth 2.0 tokens
    #  d) JWK sets that have been retrieved from jwk_uri's
    #  e) resolved OP metadata when using OIDCProviderMetadataUrl
    #  f) temporary state associated with Request URI's
    # must be one of \"shm\", \"memcache\", \"file\" or, if Redis support is compiled in, \"redis\" 
    # When not defined, "shm" (shared memory) is used.
    #OIDCCacheType [shm|memcache|file[|redis]]

    # Indicate whether data in the cache backend should be encrypted.
    # When not defined the default is "Off" for the "shm" backend and "On" for all other cache backends
    #OIDCCacheEncrypt [On|Off]

    # When using OIDCCacheType "file":
    # Directory that holds cache files; must be writable for the Apache process/user.
    # When not specified a system defined temporary directory (/tmp) will be used.
    #OIDCCacheDir /var/cache/apache2/mod_auth_openidc/cache


    ########################################################################################
    #
    # Advanced Settings
    #
    ########################################################################################

    # TODO: what advanced settings do we need?

    # Defines an external OP Discovery page. That page will be called with:
    #    <discovery-url>?oidc_callback=<callback-url>
    # additional parameters may be added, a.o. `target_link_uri`, `x_csrf` and `method`.
    #
    # An Issuer selection can be passed back to the callback URL as in:
    #    <callback-url>?iss=[${issuer}|${domain}|${e-mail-style-account-name}][parameters][&login_hint=<login-hint>][&scopes=<scopes>][&auth_request_params=<params>]
    # where the <iss> parameter contains the URL-encoded issuer value of
    # the selected Provider, or a URL-encoded account name for OpenID
    # Connect Discovery purposes (aka. e-mail style identifier), or a domain name.
    # [parameters] contains the additional parameters that were passed in on the discovery request (e.g. target_link_uri=<url>&x_csrf=<x_csrf>&method=<method>&scopes=<scopes>)
    #
    # When not defined the bare-bones internal OP Discovery page is used.
    #OIDCDiscoverURL <discovery-url>

    # Defines a default URL to be used in case of 3rd-party-init-SSO when no explicit target_link_uri
    # has been provided. The user is also redirected to this URL in case an invalid authorization
    # response was received.
    #
    # By default, when no OIDCDefaultURL is set, an expired state cookie will lead to an HTML error page
    # being sent to the browser explaining what happened. To copy that (legacy) behaviour when OIDCDefaultURL is set,
    # so that the browser is no longer redirected to the OIDCDefaultURL in case of state cookie expiry, use:
    #   SetEnvIfExpr true OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT=true 
    #
    # The default is to not redirect the browser to any URL but return an HTTP/HTML error to the user.
    #OIDCDefaultURL <default-url>

    # Defines a default URL where the user is sent to after logout, which may be overridden explicitly during logout.
    # When not defined and no URL was passed explicitly, a default internal page will be shown.
    #OIDCDefaultLoggedOutURL <url>

    # The prefix to use when setting claims (openid-connect or oauth20) in the HTTP headers/environment variables.
    # This prefix should not be set to "" except when combined with OIDCWhiteListedClaims to maintain a secure setup.
    # When not defined, the default "OIDC_CLAIM_" is used.
    # TODO: perhaps useful to set env as oidc.claim.X instead of OIDC_CLAIM_X
    #OIDCClaimPrefix <prefix>
    #OIDCClaimPrefix "oidc.claim."

    # The claim that is used when setting the REMOTE_USER variable on OpenID
    # Connect protected paths.
    # If the claim name is postfixed with a \"@\", the claim value will be 
    # post-fixed with the \"iss\" value value (with leading "https://" stripped)
    # to make this value unique across different OPs.
    # When not defined the default "sub@" is used.
    # NOTE: recommendations are to use the persistent sub or oid claims here
    # to avoid potential changes causing ID problems. The upn or email value
    # can in principle be used instead but may cause such trouble.
    OIDCRemoteUserClaim "sub"


    # Define the way in which the (processed) claims and tokens are passed to the application environment:
    # "none": no claims/tokens are passed
    # "environment": claims/tokens are passed as environment variables
    # "headers": claims/tokens are passed in headers (also useful in reverse proxy scenario's)
    # "both": claims/tokens are passed as both headers as well as environment variables (default)
    #
    # A second parameter can be specified that defines the encodong applied to all values passed in headers
    # and environment variables:
    #   "latin1" applies ISO-8859-1 encoding: this may result in out of bound characters converted to the "?" character.
    #   "base64url" applies base64url encoding
    #   "none" applies no encoding and copies literal values from the claims into the headers/environment variables
    # When not defined the default is "both" and "latin1" encoding is applied to the header/environment values.
    #
    # The access token is passed in OIDC_access_token; the access token expiry is passed in OIDC_access_token_expires.
    # The refresh token is only passed in OIDC_refresh_token if enabled for that specific directory/location (see: OIDCPassRefreshToken)
    #OIDCPassClaimsAs [none|headers|environment|both] [latin1|base64url|none]
    # NOTE: the default encoding was changed from none to latin1 in release 2.4.15
    # NOTE: do NOT quote value here as it must support two separate arguments
    OIDCPassClaimsAs both


    ### Additional OpenID Connect settings. 
    # Please refer to the documented example at:
    # https://github.com/zmartzone/mod_auth_openidc/blob/master/auth_openidc.conf


    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"

        ### TODO: implement any required OpenID Connect discovery here

        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Set additional cookies
    #RewriteRule .* -  [CO=]

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    ### Any special directories without openid requirement should go here...

    # Currently no such dirs except the globally configured ones at the top


    #### All other locations share basic OpenID Connect conf and can use SSL envs

    <Directory "/home/mig/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    # Jupyter OpenID Connect auth
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-oidc.conf

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    <Directory "/home/mig/mig/cgi-bin">
        Options +ExecCGI
        AuthType openid-connect
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # TODO: copied from OpenID 2.0 vhost - does it apply here as well?
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        AuthType openid-connect
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # TODO: copied from OpenID 2.0 vhost - does it apply here as well?
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/">
        # Require a valid OpenID Connect login for access to user home and all
        # user sub directories.
        AuthType openid-connect
        require valid-user
        # Access to user home dirs is also further limited in .htaccess
        # files there.
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # TODO: copied from OpenID 2.0 vhost - does it apply here as well?
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/state/user_home/*/">
        # Add additional auth restrictions with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "/home/mig/state/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>
    <LocationMatch "^/(index.html)?$">
        # Grant full access to landing page in user_home so that openid relying
        # party verification can work from index.html without an openid loop. 
        # The access restriction is there on individual user sub directories.
        # In apache-2.2 we must use Satisfy any and in 2.4 Require all granted
        # rather than Authtype None here.
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Satisfy Any
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Satisfy Any
        </IfVersion>
    </LocationMatch>
    # We allow access to cgi-sid with auth here just like for the cert case
    <Directory "/home/mig/mig/cgi-sid">
        Options +ExecCGI
        AuthType openid-connect
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # TODO: copied from OpenID 2.0 vhost - does it apply here as well?
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # TODO: update to use OpenID Connect email as username here?
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    #<LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
    #    SSLUserName SSL_CLIENT_S_DN_Email
    #</LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-oid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Common destinations without explicit auth or rewrite requirements
    # NOTE: OpenID Connect server might need to check cgi-sid/* and vanity URI
    # NOTE: autocreate must be kept out of 2FA to work
    #RewriteCond %{REQUEST_URI} ^/dynamic/redirect_uri [OR]
    RewriteCond %{REQUEST_URI} ^/(favicon.ico|)$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/(autocreate|autologout|logout).py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known|openid|cgi-sid)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # 2FA helpers based on our own 2FA helper in /home/mig/mig/cgi-auth/twofactor.py
    #
    # We add the QSA flag to have apache automatically append the query.
    # NOTE: OpenID Connect vanity address should be allowed through
    RewriteCond %{REQUEST_URI} !^/dynamic/redirect_uri
    RewriteCond %{REQUEST_URI} !^/wsgi-bin/twofactor.py
    RewriteCond %{HTTP_COOKIE} !^.*2FA_Auth=[a-zA-Z0-9]+ [OR]
    RewriteCond %{HTTP_COOKIE} ^.*2FA_Auth=([a-zA-Z0-9]+) 
    #RewriteCond /home/mig/state/twofactor_home/%{REMOTE_ADDR}_%1 !-l [OR]
    RewriteCond /home/mig/state/twofactor_home/%1 !-f
    RewriteRule ^(.*)$ /wsgi-bin/twofactor.py?redirect_url=$1 [QSA,L,R=302]

    # Now any 2FA is done so we proceed to scripting targets
    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-cert)/
    RewriteRule ^ - [L]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{REQUEST_URI} !^/dynamic/redirect_uri
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]


    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond /home/mig/state/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want /cert_redirect/PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=NBI/OU=NA/CN=Jonas Bardino/emailAddress=bardino@nbi.ku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=NBI+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@nbi.ku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:/home/mig/mig/server/chkuserroot.py testuser:testgroup

    # NOTE: the REMOTE_USER below requires a recent mod_auth_openidc to work.
    #       It was just empty with mod_auth_openidc-1.8.8 but works with 2.4.12
    # If REMOTE_USER isn't available in the rewrite below we fall-back to cat.py
    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} ^$
    RewriteRule ^/cert_redirect/(.*)$ /wsgi-bin/cat.py?path=$1&output_format=file&flags=b [R,L]
    # Same with fall back to CGI 
    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} ^$
    RewriteRule ^/cert_redirect/(.*)$ /cgi-bin/cat.py?path=$1&output_format=file&flags=b [R,L]

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Fake certificate DN so that we can modify it further without PATH
    # interference. It may already be on final format but that doesn't hurt.
    # REMOTE_USER is only available in later stages so we must use
    # LA-U:REMOTE_USER and it contains the unique user ID (upn, email-style).
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 
    # NOTE: do NOT prefix REMOTE_USER with slash - it leads to '+' prefix below

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /cert_mangle/%{LA-U:REMOTE_USER}/cert_mangle/$1 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^/cert_mangle/(.*)\ (.*)/cert_mangle/(.*)$ /cert_mangle/$1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^/cert_mangle/(.*)/(.*)/cert_mangle/(.*)$ /cert_mangle/$1+$2/cert_mangle/$3 [N]

    # Finally remove certificate marker and unescape previously escaped path
    # IMPORTANT: all major browsers have trouble to some extent when accessing
    # the resulting cert_redirect data if we let the rules proceed as in the
    # cert case ([N]). This leads to subtle errors like IE and Chrome returning
    # an error instead of downloading e.g. PDF files when double clicking in
    # Files and FF not actually applying Settings -> style. Strangely enough
    # FF succeeds in the former and Chrome+IE in the latter case.
    # We explicitly SSL proxy ([P]) to work around the issues.

    # TODO: is this OpenID 2.0 inherited proxy actually needed in this case?
    # NOTE: we proxy here to make sure we only target cert mangled paths.
    # It does NOT mean that we skip chroot check below as that will still
    # happen in the new request caused by the proxy'ing.
    RewriteRule ^/cert_mangle/(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [P]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    # NOTE: OpenID Connect vanity address should be allowed through
    RewriteCond %{REQUEST_URI} !^/dynamic/redirect_uri
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]

    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) /home/mig/state/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>

    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia

    #
    # JupyterHub server
    #
    #Include /etc/apache2/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    #ProxyPass /paraview http://localhost:8081/paraview

    # This is the path of the mapping file
    #RewriteMap session-to-port txt:/home/mig/state/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    #RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    #RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

    <Directory /home/mig/mig/cgi-auth>
        AuthType openid-connect
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
        Require valid-user
    </Directory>

</VirtualHost>
</IfDefine>
</IfDefine>
</IfModule>


# Configure TLS/SSL with session-id virtual host
<IfDefine SID_FQDN>
<IfDefine SID_PORT>
# For job file access on resources and secure pages without user mandatory auth
<VirtualHost ${SID_FQDN}:${SID_PORT}>
    # General setup for the virtual host
    ServerName ${SID_FQDN}
    DocumentRoot "/home/mig/state/webserver_home"
    ErrorLog /var/log/apache2/ssl-sid-error.log
    CustomLog /var/log/apache2/ssl-sid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    #SSLCertificateFile /home/mig/certs/${SID_FQDN}/server.crt
    #SSLCertificateKeyFile /home/mig/certs/${SID_FQDN}/server.key
    #SSLCertificateChainFile /home/mig/certs/${SID_FQDN}/server.ca.pem

    ScriptAlias /cgi-sid/ "/home/mig/mig/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "/home/mig/mig/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "/home/mig/mig/software-repository/swrepo.py"
    </IfModule>

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Remote Seafile, OpenID, etc. requires SSL proxy
    #SSLProxyEngine on

    ### Any special directories without auth requirement should go here...

    # Currently no such dirs except the globally configured ones at the top

    #### All other locations share basic conf and can use SSL envs

    <Directory "/home/mig/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "/home/mig/mig/wsgi-bin">
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "/home/mig/mig/cgi-sid">
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # SID access from resources
    Alias /sid_redirect/ "/home/mig/state/webserver_home/"
    <Directory "/home/mig/state/webserver_home/">
        # Remove source address based access limitations here
        # Access is restricted by long random hashed session IDs
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # Low level share link file access from e.g. external users
    # High level file management goes through cgi-sid
    # Please refer to the notes in shared.sharelinks for sharelink ID details
    AliasMatch "^/share_redirect/([a-hA-H].*)" "/home/mig/state/sharelink_home/read-only/$1"
    AliasMatch "^/share_redirect/([i-pI-P].*)" "/home/mig/state/sharelink_home/read-write/$1"
    AliasMatch "^/share_redirect/([q-xQ-X].*)" "/home/mig/state/sharelink_home/write-only/$1"
    <Directory "/home/mig/state/sharelink_home">
        # Don't allow direct access here, only in sub directories
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Deny from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all denied
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Deny from all
        </IfVersion>
    </Directory>
    <IfModule mod_actions.c>
    <Directory "/home/mig/state/sharelink_home/read-only">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit GET>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept GET>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
    </Directory>
    <Directory "/home/mig/state/sharelink_home/write-only">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
        Script PUT /cgi-sid/put
        Script SHAREPUT /cgi-sid/put
    </Directory>
    <Directory "/home/mig/state/sharelink_home/read-write">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit GET PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept GET PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
        Script PUT /cgi-sid/put
        Script SHAREPUT /cgi-sid/put
    </Directory>
    </IfModule>

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/apache2/ssl-sid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Redirect requests to SID root to public web page e.g. from menu logo click
    RewriteCond %{REQUEST_URI} ^/*$
    RewriteRule ^/*$ https://${SID_FQDN}:${SID_PORT}/public/ [R,L]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    #RewriteCond %{REQUEST_URI} ^/seafile//.*$
    #RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|.well-known)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Stay on wsgi-bin if user comes from that already, otherwise use cgi-sid
    RewriteCond %{REQUEST_URI} ^/sharelink/.*$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/sharelink/(.*)$ /wsgi-bin/ls.py?share_id=$1 [L,R]
    RewriteCond %{REQUEST_URI} ^/sharelink/.*$
    RewriteRule ^/sharelink/(.*)$ /cgi-sid/ls.py?share_id=$1 [L,R]

    # Set up chroot checking helper
    
    RewriteMap chksidroot prg:/home/mig/mig/server/chksidroot.py testuser:testgroup

    # Prevent e.g. symlinks escaping user chroots hidden behind session or
    # sharelink symlinks.
    # Apache starts chksidroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond ${chksidroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]

    ### Seafile (optional)

    # Seafile media files - rely on symlink to latest install
    #Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    #<LocationMatch ^/(seafile|seafmedia|seafhttp)>
    #    <IfVersion > 2.2>
    #        <IfModule mod_access_compat.c>
    #            Order allow,deny
    #            Allow from all
    #        </IfModule>
    #        <IfModule !mod_access_compat.c>
    #            Require all granted
    #        </IfModule>
    #    </IfVersion>
    #    <IfVersion <= 2.2>
    #        Order allow,deny
    #        Allow from all
    #    </IfVersion>
    #</LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    #ProxyPass /seafhttp http://127.0.0.1/seafhttp
    #ProxyPassReverse /seafhttp http://127.0.0.1/seafhttp
    #RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    #SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    #ProxyPass /seafile http://127.0.0.1/seafile
    #ProxyPassReverse /seafile http://127.0.0.1/seafile
    #ProxyPass /seafmedia http://127.0.0.1/seafmedia
    #ProxyPassReverse /seafmedia http://127.0.0.1/seafmedia
</VirtualHost>
</IfDefine>
</IfDefine>
